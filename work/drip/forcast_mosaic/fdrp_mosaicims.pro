;+; NAME:;       FDRP_MOSAICIMS; ; PURPOSE:; 	 	Stitch a stack of frames together into a mosaic.  Also create a map of ;		exposure time and weight pre pixel.;; CALLING SEQUENCE:;       MOSAICIMS,IMAGES,EXPTIME,BPMASK,MOSAIC,EXPMAP,WEIGHTMAP [,;			BUFFER=buffer,INTER=inter,DISPLAY_SCALE=disp_scale,;			SHIFTS_IN=shifts_in,XCORR=xcorr,SCALE=scale];;       			; INPUTS:;      IMAGES - IDL array containing all the frames to be mosaiced;       			 as a data cube, array(*,*,n).;		EXPTIME - Array of exposure times in same order as IMAGES.  ;		BPMASK - Stack of image masks, one per frame.;		; OUTPUT:;		MOSAIC - Mosaic array.  Total counts per pixel (summed).;		EXPMAP - Total exposure time per pixel for mosaic, as found in header.;		WEIGHTMAP - Number of good values per pixel.;	   ; OPTIONAL KEYWORDS:;		BUFFER= - Edge buffer size.  This can help avoid prolems with edges in cross correlation.;		/INTER - determine shifts for each frame interactively.;		DISPLAY_SCALE= - Display scaling for interactive mode (crude).;		SHIFTS_IN= - Array of input shifts (from IMREG) to use for each image.;		/XCORR - Perform cross-correlation to find best shift for each frame. Best used;					in conjunction with /INTER.
;		ROT_ANGLE = optional array of rotation angles;		;; VERSION HISTORY:;       7-1-2003 - RYS:  First good version..based on mosaic program written for LWS frames.;       9-22-2003 (BETA) -- RYS: Replaced header I/O with fixed exptime input.			;-;----------------------------------------------------;Get initial shifts interactively...function getshifts_inter,mosaic,newframe,expmap,newexp,disp_scaleloadct,0;;display mosaic and framesdisplay_frame,mosaic/expmap,0,'Mosaic',disp_scaledisplay_frame,newframe/newexp,1,'New',disp_scale;;get gross shiftprint,'Click on common feature in  new frame...'cursor,xnew,ynew,/dev;;display mosaic againdisplay_frame,mosaic/expmap,0,'Mosaic',disp_scaleprint,'Click on same feature in  mosaic...'cursor,x0,y0,/devreturn,[x0-xnew,y0-ynew]end;----------------------------------------------------;function xcorr_shifts,im0,im1,x0,y0,offsets0function xcorr_shifts,im0,im1,offsets0im0_size=size(im0)im1_size=size(im1)xbuff0=(im0_size[1] - im1_size[1])/2.0ybuff0=(im0_size[2] - im1_size[2])/2.0;expand arrays to same sizexsize=max([im0_size[1],im1_size[1]])ysize=max([im0_size[2],im1_size[2]])im0_new=fltarr(xsize,ysize)im1_new=fltarr(xsize,ysize)im0_new[*,*]=0im1_new[*,*]=0im0_new[0,0]=im0[*,*]im1_new[0,0]=im1[*,*]im1_sh=shift(im1_new,offsets0[0],offsets0[1])xlim0=[xbuff0,xsize-xbuff0-1]ylim0=[ybuff0,ysize-ybuff0-1]print,xlim0,ylim0;print,xlim1,ylim1help,im0_new,im1_shcorrel_optimize_rys,im0_new[xlim0[0]:xlim0[1],ylim0[0]:ylim0[1]],$	im1_sh[xlim0[0]:xlim0[1],ylim0[0]:ylim0[1]],xoff,yoff,50,/numpix,/print	;im1_sh[xlim1[0]:xlim1[1],ylim1[0]:ylim1[1]],$	;xoff_init=offsets0[0],yoff_init=offsets0[1]print,'Cross Correlation:  ',xoff,yoffreturn,offsets0+[xoff,yoff]end;----------------------------------------------------pro fdrp_mosaicims,ims,exptime_arr,bpmask,mosaic,expmap,weightmap,$	BUFFER=edge_buffer,INTER=inter,DISPLAY_SCALE=disp_scale,$	SHIFTS_IN=shifts_in,XCORR=xcorr,ROT_ANGLE=rot_angle	on_error,1print,'------------------------------'print,'MOSAICIMS:  Starting...'if (n_params() NE 6) then begin	print,'Calling Sequence: MOSAICIMS,IMAGES,EXPTIME,BPMASK,MOSAIC,EXPMAP,WEIGHTMAP [,'	print,' BUFFER=buffer,INTER=inter,DISPLAY_SCALE=disp_scale,SHIFTS_IN=shifts_in,XCORR=xcorr]'	returnendifif not keyword_set(disp_scale) then disp_scale=10

if not keyword_set(rot_angle) then begin
	rot_angle=exptime_arr
	rot_angle[*]=0.0
endif  
imsize=size(ims)nfiles=imsize[3];initialize mosaic and exposure time map;First image is assumed to be (0,0).mosaic=fltarr(imsize[1]+100,imsize[2]+100)mosaic[50:imsize[1]+49,50:imsize[2]+49]=ims[*,*,0];Now create weight map adn intialize using bp mask for first imageweightmap=mosaicweightmap[50:imsize[1]+49,50:imsize[2]+49]=1.0  ;initialize all values with weight=1.0;Now get bpmask bp_map=mosaicbp_map[50:imsize[1]+49,50:imsize[2]+49]=bpmask[*,*,0]index=where(bp_map[*,*] NE 0,count)if count GT 0 then begin	mosaic[index] = 0.0  ;initialize bad pixels to zero;	mosaic[where(bpmask[*,*,0] NE 0)] = 0.0  ;initialize bad pixels to zero	weightmap[index] = 0.0  ;set bad pixels to 0.0 in weightmap;	weightmap[where(bpmask[*,*,0] NE 0)] = 0.0  ;set bad pixels to 0.0 in weightmapendif;Now get exposure time per pixelprint,'MOSAICIMS:  Initial frame...'expmap=mosaicexptime=exptime_arr[0];exptime=sxpar(imhdrs[*,0],'ITIME')*sxpar(imhdrs[*,0],'CO_ADDS');exptime=sxpar(imhdrs[*,0],'EXPTIME')expmap[50:imsize[1]+49,50:imsize[2]+49]=exptimeprint,'MOSIACIMS:  Exposure time:  '+string(exptime);now initialize bad pixels to zero in exposure mapexpmap=expmap*weightmapbasis=[0,0];rotate all framesmosaic=rot(mosaic,rot_angle[0])weightmap=rot(weightmap,rot_angle[0])expmap=rot(expmap,rot_angle[0]);--------------------------------------------------;Now begin loop, add each image to mosaic in turn...for i=1,nfiles-1 do begin;for i=1,1 do beginprint,'MOSAICIMS:  Adding frame  '+string(i)mos_size=size(mosaic)print,'New Frame:  'newframe=fltarr(imsize[1]+100,imsize[2]+100)newframe[50:imsize[1]+49,50:imsize[2]+49]=ims[*,*,i]newexp=newframenewexp[50:imsize[1]+49,50:imsize[2]+49]=exptime_arr[i];newexptime=sxpar(imhdrs[*,i],'ITIME')*sxpar(imhdrs[*,i],'CO_ADDS');newexptime=sxpar(imhdrs[*,i],'EXPTIME');newexp[*,*]=newexptimeprint,'MOSAICIMS:  Exposure time =  '+string(exptime_arr[i])newbp=newframenewbp[50:imsize[1]+49,50:imsize[2]+49]=bpmask[*,*,i]newweight=newframenewweight[50:imsize[1]+49,50:imsize[2]+49]=1.0  ;start with all pixels good and...;now find bad pixels and set weight to 0index=where(newbp NE 0,count)if count GT 0 then begin	newframe[index]=0.0;   newframe[where(bpmask[*,*,i] NE 0,count)] = 0.0  ;initialize bad pixels to zero	newweight[index] = 0.0;	newweight[where(bpmask[*,*,i] NE 0,count)] = 0.0  ;set badpixels back to 0 weightendifnew_imsize=size(newframe)

;now rotate all arrays:
;rotate new frame
newframe=rot(newframe,rot_angle[i])
newexp=rot(newexp,rot_angle[i])
newweight=rot(newweight,rot_angle[i]);Get initial shiftscase 1 of	keyword_set(inter) : init_shift=getshifts_inter(mosaic,newframe,expmap,newexp,disp_scale)	keyword_set(shifts_in) : begin		reg_shift=[shifts_in[0,i],shifts_in[1,i]]		init_shift=reg_shift-basis		if (reg_shift[0] LT basis[0]) then basis[0] = reg_shift[0]		if (reg_shift[1] LT basis[1]) then basis[1] = reg_shift[1]		end	else : init_shift=[0,0]endcase	print,'MOSAICIMS:  Initial Shifts:  ',init_shiftif keyword_set(xcorr) then $	shift=xcorr_shifts(mosaic,newframe,init_shift) $	else shift=init_shiftprint,'MOSAICIMS:  Final Shifts: ',shiftxinit=max([mos_size[1],new_imsize[1]])yinit=max([mos_size[2],new_imsize[2]]);now create expanded canvas for mosiac if shift[0] LE 0 then xsize_new=xinit+abs(shift[0])if shift[0] GT 0 then xsize_new=max([xinit,new_imsize[1]+abs(shift[0])])if shift[1] LE 0 then ysize_new=yinit+abs(shift[1])if shift[1] GT 0 then ysize_new=max([yinit,new_imsize[2]+abs(shift[1])])mosaic_expand=fltarr(xsize_new,ysize_new)newframe_expand=fltarr(xsize_new,ysize_new)expmap_expand=fltarr(xsize_new,ysize_new)newexp_expand=fltarr(xsize_new,ysize_new)weightmap_expand=fltarr(xsize_new,ysize_new)newweight_expand=fltarr(xsize_new,ysize_new);mosaic_expand=fltarr(mos_size[1]+abs(shift[0]),mos_size[2]+abs(shift[1]));newframe_expand=fltarr(mos_size[1]+abs(shift[0]),mos_size[2]+abs(shift[1]))newframe_expand[*,*]=0.0mosaic_expand[*,*]=0.0expmap_expand[*,*]=0.0newexp_expand[*,*]=0.0weightmap_expand[*,*]=0.0newweight_expand[*,*]=0.0if (shift[0] GE 0) AND (shift[1] GE 0) then begin	mosaic_expand[0,0]=mosaic[*,*]	newframe_expand[0,0]=newframe[*,*]	expmap_expand[0,0]=expmap[*,*]	newexp_expand[0,0]=newexp[*,*]	weightmap_expand[0,0]=weightmap[*,*]	newweight_expand[0,0]=newweight[*,*]endifif (shift[0] LT 0) AND (shift[1] GE 0) then begin	mosaic_expand[abs(shift[0]),0]=mosaic[*,*]	newframe_expand[abs(shift[0]),0]=newframe[*,*]	expmap_expand[abs(shift[0]),0]=expmap[*,*]	newexp_expand[abs(shift[0]),0]=newexp[*,*]	weightmap_expand[abs(shift[0]),0]=weightmap[*,*]	newweight_expand[abs(shift[0]),0]=newweight[*,*]endif	if (shift[0] GE 0) AND (shift[1] LT 0) then begin	mosaic_expand[0,abs(shift[1])]=mosaic[*,*]	newframe_expand[0,abs(shift[1])]=newframe[*,*]	expmap_expand[0,abs(shift[1])]=expmap[*,*]	newexp_expand[0,abs(shift[1])]=newexp[*,*]	weightmap_expand[0,abs(shift[1])]=weightmap[*,*]	newweight_expand[0,abs(shift[1])]=newweight[*,*]endif	if (shift[0] LT 0) AND (shift[1] LT 0) then begin	mosaic_expand[abs(shift[0]),abs(shift[1])]=mosaic[*,*]	newframe_expand[abs(shift[0]),abs(shift[1])]=newframe[*,*]	expmap_expand[abs(shift[0]),abs(shift[1])]=expmap[*,*]	newexp_expand[abs(shift[0]),abs(shift[1])]=newexp[*,*]	weightmap_expand[abs(shift[0]),abs(shift[1])]=weightmap[*,*]	newweight_expand[abs(shift[0]),abs(shift[1])]=newweight[*,*]endifnewframe_expand=shift(newframe_expand,shift[0],shift[1])newexp_expand=shift(newexp_expand,shift[0],shift[1])newweight_expand=shift(newweight_expand,shift[0],shift[1])
;now make flux maps for scalingmos_flux=mosaic_expand/expmap_expandnew_flux=newframe_expand/newexp_expandmos_flux[where(~finite(mos_flux))]=0.0new_flux[where(~finite(new_flux))]=0.0;reset all values in weightmap to 1.0 to find overlap.temp=weightmap_expandtemp[where(temp GT 0.0)]=1.0temp=newweight_expand+temp;determine regions of overlapoverlap=where(temp EQ 2.0);determine *flux* scaling in overlap regionsflux_scale=mean(mos_flux[overlap])/mean(new_flux[overlap])print,'Flux Scaling Factor:  '+string(flux_scale);now scale new flux map and convert back to countsnew_flux=new_flux*flux_scalenewframe_expand=new_flux*newexp_expand;add newweightmap to existing weightmapweightmap=newweight_expand+weightmap_expand;exposure time map is exposure time multiplied by the weightmapexpmap=(newexp_expand*newweight_expand)+expmap_expand

;sum counts per pixel(sclaed) and multiply by weight to get rid of bad pixels
mosaic=(newframe_expand*newweight_expand)+mosaic_expandendforprint,'MOSAICIMS:  ...Complete'print,'-----------------------------------'end